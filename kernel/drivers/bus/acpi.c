#include "acpi.h"#include "../../lib/log.h"#include "string.h"#include "../include/cast.h"static struct acpi_rsdp* rsdp = NULL;static struct acpi_rsdt* rsdt = NULL;static bool acpi_available = false;static uint32_t cpu_count = 0;static uint32_t local_apic_addr = 0;static uint32_t io_apic_addr = 0;static bool acpi_checksum(void* data, const uint32_t length){    uint8_t sum = 0;    const uint8_t* ptr = (uint8_t*)data;    for (uint32_t i = 0; i < length; i++)    {        sum += ptr[i];    }    return sum == 0;}static struct acpi_rsdp* acpi_find_rsdp(void){    uint8_t* search_start = (uint8_t*)0x000E0000;    const uint8_t* search_end = (uint8_t*)0x000FFFFF;    for (uint8_t* ptr = search_start; ptr < search_end; ptr += ACPI_RSDP_ALIGN)    {        if (memcmp(ptr, ACPI_RSDP_SIGNATURE, 8) == 0)        {            struct acpi_rsdp* candidate = (struct acpi_rsdp*)ptr;            if (acpi_checksum(candidate, 20))            {                return candidate;            }        }    }    return NULL;}static void acpi_parse_madt(struct acpi_madt* madt){    if (!madt)    {        return;    }    local_apic_addr = madt->local_apic_address;    cpu_count = 0;    uint8_t* ptr = madt->entries;    const uint8_t* end = (uint8_t*)madt + madt->header.length;    while (ptr < end)    {        struct acpi_madt_entry* entry = (struct acpi_madt_entry*)ptr;        switch (entry->type)        {            case ACPI_MADT_TYPE_LOCAL_APIC:            {                const struct acpi_madt_local_apic* lapic = (struct acpi_madt_local_apic*)entry;                if (lapic->flags & 1)                {                    cpu_count++;                    log_info_fmt("ACPI: Found CPU - Processor ID: %d, APIC ID: %d",                                 lapic->processor_id, lapic->apic_id);                }                break;            }            case ACPI_MADT_TYPE_IO_APIC:            {                struct acpi_madt_io_apic* ioapic = (struct acpi_madt_io_apic*)entry;                io_apic_addr = ioapic->io_apic_address;                log_info_fmt("ACPI: Found I/O APIC - ID: %d, Address: 0x%x",                             ioapic->io_apic_id, ioapic->io_apic_address);                break;            }            case ACPI_MADT_TYPE_INT_OVERRIDE:            {                log_info("ACPI: Found Interrupt Override entry");                break;            }        }        if (entry->length == 0)        {            break;        }        ptr += entry->length;    }    log_info_fmt("ACPI: CPU Count: %d, Local APIC: 0x%x, IO APIC: 0x%x",                 cpu_count, local_apic_addr, io_apic_addr);}void acpi_init(void){    log_info("ACPI: Initializing ACPI subsystem");    rsdp = acpi_find_rsdp();    if (!rsdp)    {        log_warn("ACPI: RSDP not found, ACPI not available");        acpi_available = false;        return;    }    log_info_fmt("ACPI: RSDP found at address %p", (void*)rsdp);    const uint32_t rsdt_phys = *(uint32_t*)((uint8_t*)rsdp + 0x10);    rsdt = PTR_FROM_U32_TYPED(struct acpi_rsdt, rsdt_phys);    if (!rsdt || !acpi_checksum(rsdt, rsdt->header.length))    {        log_error("ACPI: RSDT checksum invalid or RSDT not accessible, ACPI not available");        acpi_available = false;        return;    }    log_info("ACPI: RSDT checksum valid");    acpi_available = true;    log_info_fmt("ACPI: Parsing RSDT with length %d", rsdt->header.length);    struct acpi_madt* madt = (struct acpi_madt*)acpi_find_table(ACPI_SIG_MADT);    if (madt)    {        log_info("ACPI: MADT found, parsing entries");        acpi_parse_madt(madt);    }    else    {        log_warn("ACPI: MADT not found");    }    const struct acpi_fadt* fadt = (struct acpi_fadt*)acpi_find_table(ACPI_SIG_FADT);    if (fadt)    {        log_info_fmt("ACPI: FADT found, DSDT Address: 0x%x", fadt->dsdt);    }    else    {        log_warn("ACPI: FADT not found");    }}bool acpi_is_available(void){    return acpi_available;}struct acpi_sdt_header* acpi_find_table(uint32_t signature){    if (!rsdt)    {        return NULL;    }    const uint32_t entry_count = (rsdt->header.length - sizeof(struct acpi_sdt_header)) / 4;    for (uint32_t i = 0; i < entry_count; i++)    {        const uint32_t phys = rsdt->tables[i];        struct acpi_sdt_header* header = PTR_FROM_U32_TYPED(struct acpi_sdt_header, phys);        if (header->signature == signature)        {            if (acpi_checksum(header, header->length))            {                return header;            }            else            {                log_error_fmt("ACPI: Table with signature %.4s has invalid checksum",                              (char*)&signature);            }        }    }    return NULL;}uint32_t acpi_get_cpu_count(void){    return cpu_count;}uint32_t acpi_get_local_apic_address(void){    return local_apic_addr;}uint32_t acpi_get_io_apic_address(void){    return io_apic_addr;}void acpi_list_tables(void){    if (!rsdt)    {        log_info("ACPI not available\n");        return;    }    log_info("\nACPI Tables:\n");    log_info("============\n");    const uint32_t entry_count = (rsdt->header.length - sizeof(struct acpi_sdt_header)) / 4;    for (uint32_t i = 0; i < entry_count; i++)    {        struct acpi_sdt_header* header = PTR_FROM_U32_TYPED(struct acpi_sdt_header, rsdt->tables[i]);        char sig[5];        memcpy(sig, &header->signature, 4);        sig[4] = '\0';        if (!acpi_checksum(header, header->length))        {            log_error_fmt("ACPI: Table %.4s has invalid checksum", sig);        }        else        {            log_info_fmt("ACPI: Table %.4s checksum valid", sig);        }        log_info_fmt("ACPI: Table %.4s Length: %d", sig, header->length);        log_info_fmt("OEM ID: %.6s, OEM Table ID: %.8s", header->oem_id, header->oem_table_id);        log_info_fmt("Creator ID: 0x%x, Creator Revision: 0x%x",                     header->creator_id, header->creator_revision);    }    log_info_fmt("Total ACPI Tables: %d\n", entry_count);}